.TH "/home/runner/work/PEPITAS-Cryptocurrency/PEPITAS-Cryptocurrency/headers/cryptosystem/signature.h" 3 "Sun Jul 28 2024" "PEPITAS CRYPTOCURRENCY" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/PEPITAS-Cryptocurrency/PEPITAS-Cryptocurrency/headers/cryptosystem/signature.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <err\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <openssl/crypto\&.h>\fP
.br
\fC#include <openssl/ssl3\&.h>\fP
.br
\fC#include <openssl/rsa\&.h>\fP
.br
\fC#include <openssl/err\&.h>\fP
.br
\fC#include 'blockchain/wallet\&.h'\fP
.br
\fC#include 'blockchain/block\&.h'\fP
.br
\fC#include 'validation/epoch_man\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBsign_message\fP (char *data, size_t len_data, void *buffer)"
.br
.RI "buffer <- encrypt(SHA284(msg,len_data),wallet_priv_key) "
.ti -1c
.RI "char * \fBsign_message_with_key\fP (char *data, size_t len_data, RSA *key, void *buffer)"
.br
.RI "encrypt(SHA284(msg,len_data),key) buffer <- encrypt(SHA284(msg,len_data),key) "
.ti -1c
.RI "int \fBverify_signature\fP (void *data, size_t data_len, char *signature, RSA *pub_key)"
.br
.RI "Verifies if SHA384(data) == decrypt(signature,pub_key) "
.ti -1c
.RI "int \fBverify_block_signature\fP (\fBBlock\fP block)"
.br
.RI "Verifies if a block signature is valid\&. "
.ti -1c
.RI "int \fBverify_transaction_signature\fP (\fBTransaction\fP *transaction)"
.br
.RI "Verifies if a transaction signature is valid\&. "
.ti -1c
.RI "void \fBget_transaction_data\fP (\fBTransaction\fP *trans, char **buff, size_t *size)"
.br
.RI "Converts transactions to char * buffer\&. "
.ti -1c
.RI "void \fBwrite_blockdata\fP (\fBBlockData\fP blockdata, int fd)"
.br
.RI "Writes blockdata in a file\&. "
.ti -1c
.RI "void \fBwrite_block\fP (\fBBlock\fP block, int fd)"
.br
.RI "Writes a block in a file\&. "
.ti -1c
.RI "void \fBsign_block\fP (\fBBlock\fP *block)"
.br
.RI "Signs a block with my private key\&. "
.ti -1c
.RI "void \fBsign_block_with_key\fP (\fBBlock\fP *block, RSA *key)"
.br
.RI "Signs a block\&. "
.ti -1c
.RI "void \fBsign_transaction\fP (\fBTransaction\fP *transaction)"
.br
.RI "Signs a transaction with my private key\&. "
.ti -1c
.RI "void \fBsign_transaction_with_key\fP (\fBTransaction\fP *transaction, RSA *key)"
.br
.RI "Signs a transaction\&. "
.ti -1c
.RI "void \fBsign_block_transactions\fP (\fBBlock\fP *block)"
.br
.RI "Signs all transactions of a block with my private key\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void get_transaction_data (\fBTransaction\fP * trans, char ** buff, size_t * size)"

.PP
Converts transactions to char * buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fItransactions\fP The transaction array 
.br
\fIbuff\fP The buffer that receives the transactions 
.br
\fIsize\fP The number of transactions in the array
.RE
.PP
\fBReturns\fP
.RS 4
The buffer allocated (Must be freed)
.RE
.PP
Converts transactions to char * buffer\&.
.PP
\fBParameters\fP
.RS 4
\fItrans\fP The returned transaction 
.br
\fIbuff\fP The buffer with the serialized data 
.br
\fIindex\fP The buffer starting offset 
.RE
.PP

.PP
Definition at line 40 of file transaction\&.c\&.
.SS "void sign_block (\fBBlock\fP * block)"

.PP
Signs a block with my private key\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to sign 
.RE
.PP

.PP
Definition at line 108 of file signature\&.c\&.
.SS "void sign_block_transactions (\fBBlock\fP * block)"

.PP
Signs all transactions of a block with my private key\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to sign 
.RE
.PP

.PP
Definition at line 138 of file signature\&.c\&.
.SS "void sign_block_with_key (\fBBlock\fP * block, RSA * key)"

.PP
Signs a block\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to sign 
.br
\fIkey\fP The key to use for the signature 
.RE
.PP

.PP
Definition at line 115 of file signature\&.c\&.
.SS "char* sign_message (char * data, size_t len_data, void * buffer)"

.PP
buffer <- encrypt(SHA284(msg,len_data),wallet_priv_key) If buffer == NULL, return a new allocated buffer
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to sign 
.br
\fIlen_data\fP The length of the data 
.br
\fIbuffer\fP The buffer to put signature into 
.RE
.PP
\fBReturns\fP
.RS 4
char* 
.RE
.PP

.PP
Definition at line 10 of file signature\&.c\&.
.SS "char* sign_message_with_key (char * data, size_t len_data, RSA * key, void * buffer)"

.PP
encrypt(SHA284(msg,len_data),key) buffer <- encrypt(SHA284(msg,len_data),key) If buffer == NULL, return a new allocated buffer 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to sign 
.br
\fIlen_data\fP The length of the data 
.br
\fIkey\fP The key to use for the signature 
.br
\fIbuffer\fP The buffer to put signature into 
.RE
.PP
\fBReturns\fP
.RS 4
char* 
.RE
.PP

.PP
Definition at line 34 of file signature\&.c\&.
.SS "void sign_transaction (\fBTransaction\fP * transaction)"

.PP
Signs a transaction with my private key\&. 
.PP
\fBParameters\fP
.RS 4
\fItransaction\fP The transaction to sign 
.RE
.PP

.PP
Definition at line 122 of file signature\&.c\&.
.SS "void sign_transaction_with_key (\fBTransaction\fP * transaction, RSA * key)"

.PP
Signs a transaction\&. 
.PP
\fBParameters\fP
.RS 4
\fItransaction\fP The transaction to sign 
.br
\fIkey\fP The key to use for the signature 
.RE
.PP

.PP
Definition at line 130 of file signature\&.c\&.
.SS "int verify_block_signature (\fBBlock\fP block)"

.PP
Verifies if a block signature is valid\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to verify 
.RE
.PP
\fBReturns\fP
.RS 4
1 if valid, 0 otherwise 
.br
 
.RE
.PP

.PP
Definition at line 83 of file signature\&.c\&.
.SS "int verify_signature (void * data, size_t data_len, char * signature, RSA * pub_key)"

.PP
Verifies if SHA384(data) == decrypt(signature,pub_key) 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The buffer to verify 
.br
\fIdata_len\fP The length of the buffer 
.br
\fIsignature\fP The signature to compare with SHA384(data, len_data) 
.br
\fIpub_key\fP The RSA public key used for the decryption 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.PP
Definition at line 57 of file signature\&.c\&.
.SS "int verify_transaction_signature (\fBTransaction\fP * transaction)"

.PP
Verifies if a transaction signature is valid\&. 
.PP
\fBParameters\fP
.RS 4
\fItransaction\fP The transaction to verify 
.RE
.PP
\fBReturns\fP
.RS 4
1 if valid, 0 otherwise 
.br
 
.RE
.PP

.PP
Definition at line 95 of file signature\&.c\&.
.SS "void write_block (\fBBlock\fP block, int fd)"

.PP
Writes a block in a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to write 
.br
\fIfd\fP the file descriptor of the file in which the block is written 
.RE
.PP

.PP
Definition at line 228 of file block\&.c\&.
.SS "void write_blockdata (\fBBlockData\fP blockdata, int fd)"

.PP
Writes blockdata in a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIblockdata\fP The blockdata to write 
.br
\fIfd\fP The file descriptor of the file in which the blockdata is written 
.RE
.PP

.PP
Definition at line 196 of file block\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for PEPITAS CRYPTOCURRENCY from the source code\&.
